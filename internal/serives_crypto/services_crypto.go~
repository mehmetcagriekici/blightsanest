package services_crypto

import (
        "fmt"
	"net/http"
	"encoding/json"
)

// market type
type MarketData struct{
      ID                       string  `json:"id"`
      Symbol                   string  `json:"symbol"`
      Name                     string  `json:"name"`
      CurrentPrice             float64 `json:"current_price"`
      MarketCap                float64 `json:"market_cap"`
      MarketCapRank            int32   `json:"market_cap_rank"`
      TotalVolume              float64 `json:"total_volume"`
      High24H                  float64 `json:"high_24h"`
      Low24H                   float64 `json:"low_24h"`
      PriceChangePercentage24H float64 `json:"price_change_percentage_24h"`
      AthChangePercentage      float64 `json:"ath_change_percentage"`
}

// Available orders
type AvailableOrders string
const (
        MARKET_CAP_DESC AvailableOrders = "market_cap_desc"
	MARKET_CAP_ASC AvailableOrders  = "market_cap_asc"
)

// Price Change Percentage Available timeframes
type AvailableTimeframes string
const (
        PCP_HOUR        AvailableTimeframes = "1h"
	PCP_DAY         AvailableTimeframes = "24h"
	PCP_WEEK        AvailableTimeframes = "7d"
	PCP_MONTH       AvailableTimeframes = "30d"
	PCP_TWO_HUNDRED AvailableTimeframes = "200d"
	PCP_YEAR        AvailableTimeframes = "1y"
)

// function to fetch top gainers/losers in any timeframe
// currency=usd
// order=market_cap_{ORDER}
// price_change_percentage={TIMEFRAME}
func CryptoFetchMarket(order AvailableOrders, timeframe AvailableTimeframes, baseURL, key string) ([]MarketData, error) {
        client := &http.Client{}
        // api url
	url := fmt.Sprintf("%s/coins/markets?vs_currency=usd&order=%s&price_change_percentage%s", baseURL, order, timeframe)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
	        return []MarketData, err
	}

        // api header
	req.Header.Add("x-cg-pro-api-key: <api-key>")
	resp, err := client.Do(req)
	if err != nil {
	        return []MarketData, err
	}

        // decode the response body
	var market []MarketData
	if err := json.Unmarshal(resp.Body, &market); err != nil{
	        return []MarketData, err
	}

        return market, nil
}
