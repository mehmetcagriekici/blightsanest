// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: crypto.sql

package database

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const createCryptoList = `-- name: CreateCryptoList :one
INSERT INTO crypto (id, updated_at, crypto_key, crypto_list)
VALUES ($1, $2, $3, $4)
RETURNING id, created_at, updated_at, crypto_key, crypto_list
`

type CreateCryptoListParams struct {
	ID         uuid.UUID
	UpdatedAt  time.Time
	CryptoKey  string
	CryptoList json.RawMessage
}

func (q *Queries) CreateCryptoList(ctx context.Context, arg CreateCryptoListParams) (Crypto, error) {
	row := q.db.QueryRowContext(ctx, createCryptoList,
		arg.ID,
		arg.UpdatedAt,
		arg.CryptoKey,
		arg.CryptoList,
	)
	var i Crypto
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CryptoKey,
		&i.CryptoList,
	)
	return i, err
}

const deleteCryptoList = `-- name: DeleteCryptoList :many
DELETE FROM crypto
WHERE crypto_key = $1
RETURNING id, created_at, updated_at, crypto_key, crypto_list
`

func (q *Queries) DeleteCryptoList(ctx context.Context, cryptoKey string) ([]Crypto, error) {
	rows, err := q.db.QueryContext(ctx, deleteCryptoList, cryptoKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Crypto
	for rows.Next() {
		var i Crypto
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CryptoKey,
			&i.CryptoList,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCryptoList = `-- name: GetCryptoList :one
SELECT id, created_at, updated_at, crypto_key, crypto_list FROM crypto
WHERE crypto_key = $1 LIMIT 1
`

func (q *Queries) GetCryptoList(ctx context.Context, cryptoKey string) (Crypto, error) {
	row := q.db.QueryRowContext(ctx, getCryptoList, cryptoKey)
	var i Crypto
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CryptoKey,
		&i.CryptoList,
	)
	return i, err
}

const updateCryptoList = `-- name: UpdateCryptoList :one
UPDATE crypto
SET updated_at = $2, crypto_key = $3, crypto_list = $4
WHERE crypto_key = $1
RETURNING id, created_at, updated_at, crypto_key, crypto_list
`

type UpdateCryptoListParams struct {
	CryptoKey   string
	UpdatedAt   time.Time
	CryptoKey_2 string
	CryptoList  json.RawMessage
}

func (q *Queries) UpdateCryptoList(ctx context.Context, arg UpdateCryptoListParams) (Crypto, error) {
	row := q.db.QueryRowContext(ctx, updateCryptoList,
		arg.CryptoKey,
		arg.UpdatedAt,
		arg.CryptoKey_2,
		arg.CryptoList,
	)
	var i Crypto
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CryptoKey,
		&i.CryptoList,
	)
	return i, err
}
